{"files":[{"id":"43fe29a6-e5be-464e-a094-6073105d82c2","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"America/Sao_Paulo\",\n  \"dependencies\": {\n  },\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\"\n}"},{"id":"b5f47e56-05e6-4dc7-810f-7703a12cfd07","name":"Código","type":"server_js","source":"function myFunction() {\r\n  // Função principal para criar o quiz\r\n  function createQuizFromTemplate() {\r\n\r\n    var templateId \u003d \"11WgF3vFTaQRQcWndL22l0LxZhhp-1Zd2ErRZAWuL5RU\"; // ID do formulário modelo\r\n    var atividade \u003d \"Atividade 1\";\r\n    var idpasta \u003d \"19qnwinQ7q3TsWXtktXFNVIuQiGd_Ft1N\"; // ID da pasta destino\r\n\r\n    // Referência à pasta destino no Google Drive\r\n    var rootFolder \u003d DriveApp.getFolderById(idpasta);\r\n\r\n    // Duplicar o modelo de formulário\r\n    var templateFile \u003d DriveApp.getFileById(templateId);\r\n    var copiedFile \u003d templateFile.makeCopy(atividade, rootFolder);\r\n    var copiedForm \u003d FormApp.openById(copiedFile.getId());\r\n\r\n    // Configurar o formulário como um quiz e modificar propriedades\r\n    copiedForm.setIsQuiz(true)\r\n              .setTitle(atividade)\r\n              .setShuffleQuestions(true)\r\n              .setProgressBar(true)\r\n              .setAcceptingResponses(true)\r\n              .setShowLinkToRespondAgain(true);\r\n\r\n    // Primeira Seção: Identificação do Usuário\r\n    var matriculas \u003d [\r\n        \u0027DSI220004\u0027, \u0027DSI230017\u0027, \u0027DSI230003\u0027, \u0027DSI230023\u0027, \u0027DSI230031\u0027,\r\n        \u0027DSI230030\u0027, \u0027DSI230028\u0027, \u0027DSI230022\u0027, \u0027DSI220003\u0027, \u0027DSI230024\u0027,\r\n        \u0027DSI230001\u0027, \u0027DSI230009\u0027, \u0027DSI220012\u0027\r\n    ];\r\n\r\n    // Adiciona a pergunta de múltipla escolha para matrícula\r\n    var item \u003d copiedForm.addMultipleChoiceItem();\r\n    var choices \u003d matriculas.map(function(matricula) {\r\n        return item.createChoice(matricula);\r\n    });\r\n    item.setTitle(\u0027Escolha sua matrícula:\u0027)\r\n        .setChoices(choices)\r\n        .setRequired(true);\r\n\r\n    // Adiciona um campo de texto para o nome\r\n    copiedForm.addTextItem()\r\n              .setTitle(\u0027Digite seu nome\u0027)\r\n              .setRequired(true);\r\n\r\n    // Adiciona uma quebra de página para iniciar uma nova seção\r\n    copiedForm.addPageBreakItem()\r\n              .setTitle(atividade)\r\n              .setHelpText(\u0027Responda ao questionário a seguir.\u0027);\r\n\r\n    // Lista de perguntas para o questionário\r\nvar questions \u003d [\r\n  {\r\n    title: \u0027Sobre o conceito de Props em React Native, é correto afirmar que:\u0027,\r\n    choices: [\r\n      { text: \u0027Props são utilizadas para armazenar estados internos dos componentes.\u0027, correct: false },\r\n      { text: \u0027Props permitem modificar diretamente os dados dentro de um componente filho.\u0027, correct: false },\r\n      { text: \u0027Props são utilizadas para passar dados de um componente pai para um componente filho.\u0027, correct: true },\r\n      { text: \u0027Props são uma forma de persistência de dados no dispositivo.\u0027, correct: false },\r\n      { text: \u0027Props funcionam apenas com componentes de classe.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O hook useState serve para:\u0027,\r\n    choices: [\r\n      { text: \u0027Gerar animações nativas no app.\u0027, correct: false },\r\n      { text: \u0027Criar variáveis com ciclo de vida global.\u0027, correct: false },\r\n      { text: \u0027Manipular estilos dinamicamente.\u0027, correct: false },\r\n      { text: \u0027Gerenciar o estado de um componente funcional.\u0027, correct: true },\r\n      { text: \u0027Navegar entre telas no React Navigation.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Qual alternativa representa corretamente o uso do useRef?\u0027,\r\n    choices: [\r\n      { text: \u0027const input \u003d useRef(); para referenciar um campo de texto.\u0027, correct: true },\r\n      { text: \u0027const input \u003d useRef([]); para armazenar uma lista de objetos com estado.\u0027, correct: false },\r\n      { text: \u0027useRef é usado apenas em componentes de classe.\u0027, correct: false },\r\n      { text: \u0027useRef atualiza automaticamente o DOM como em navegadores.\u0027, correct: false },\r\n      { text: \u0027useRef dispara re-renderizações quando o valor muda.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O que o useEffect faz?\u0027,\r\n    choices: [\r\n      { text: \u0027Garante a imutabilidade dos objetos no estado.\u0027, correct: false },\r\n      { text: \u0027Renderiza um componente em um intervalo de tempo específico.\u0027, correct: false },\r\n      { text: \u0027Permite executar efeitos colaterais em componentes funcionais.\u0027, correct: true },\r\n      { text: \u0027Substitui a renderização condicional no React.\u0027, correct: false },\r\n      { text: \u0027Cria estilos dinâmicos baseados em eventos de usuário.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027TouchableOpacity é utilizado para:\u0027,\r\n    choices: [\r\n      { text: \u0027Criar uma área sensível ao toque com resposta visual de opacidade.\u0027, correct: true },\r\n      { text: \u0027Controlar a navegação entre telas.\u0027, correct: false },\r\n      { text: \u0027Armazenar dados em cache.\u0027, correct: false },\r\n      { text: \u0027Adicionar uma imagem com toque responsivo.\u0027, correct: false },\r\n      { text: \u0027Executar hooks nativos como useEffect.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Sobre o PanResponder, é correto dizer que:\u0027,\r\n    choices: [\r\n      { text: \u0027É usado para detectar gestos como pinch e rotation.\u0027, correct: false },\r\n      { text: \u0027Funciona apenas com componentes de classe.\u0027, correct: false },\r\n      { text: \u0027Captura gestos de toque, como arrastar e deslizar.\u0027, correct: true },\r\n      { text: \u0027Só pode ser usado com TouchableOpacity.\u0027, correct: false },\r\n      { text: \u0027É substituído pelo useEffect em componentes funcionais.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O Animated é utilizado para:\u0027,\r\n    choices: [\r\n      { text: \u0027Executar navegação baseada em gestos.\u0027, correct: false },\r\n      { text: \u0027Criar animações suaves e performáticas em React Native.\u0027, correct: true },\r\n      { text: \u0027Estilizar componentes com base em dados externos.\u0027, correct: false },\r\n      { text: \u0027Substituir o uso de Props em animações.\u0027, correct: false },\r\n      { text: \u0027Manipular eventos do teclado virtual.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Qual biblioteca é amplamente utilizada para navegação em apps React Native?\u0027,\r\n    choices: [\r\n      { text: \u0027React Redux\u0027, correct: false },\r\n      { text: \u0027React Context\u0027, correct: false },\r\n      { text: \u0027React Router Native\u0027, correct: false },\r\n      { text: \u0027React Navigation\u0027, correct: true },\r\n      { text: \u0027React Forms\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O que define o Stack Navigation?\u0027,\r\n    choices: [\r\n      { text: \u0027Navegação baseada em menu lateral.\u0027, correct: false },\r\n      { text: \u0027Navegação por abas com ícones.\u0027, correct: false },\r\n      { text: \u0027Navegação em pilha, onde cada tela é empilhada na anterior.\u0027, correct: true },\r\n      { text: \u0027Navegação com gestos horizontais.\u0027, correct: false },\r\n      { text: \u0027Navegação com animações nativas em SVG.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Drawer Navigation é ideal para:\u0027,\r\n    choices: [\r\n      { text: \u0027Aplicativos de página única (SPA).\u0027, correct: false },\r\n      { text: \u0027Mostrar conteúdo sensível dentro de um modal.\u0027, correct: false },\r\n      { text: \u0027Navegação lateral com um menu deslizante.\u0027, correct: true },\r\n      { text: \u0027Apps que usam mapas em tempo real.\u0027, correct: false },\r\n      { text: \u0027Exibir tabs na parte inferior da tela.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O que é AsyncStorage no contexto do React Native com Expo?\u0027,\r\n    choices: [\r\n      { text: \u0027Ferramenta para controle de navegação offline.\u0027, correct: false },\r\n      { text: \u0027Um componente visual para exibir animações.\u0027, correct: false },\r\n      { text: \u0027Um mecanismo para armazenamento persistente de dados simples.\u0027, correct: true },\r\n      { text: \u0027Uma API para capturar fotos no dispositivo.\u0027, correct: false },\r\n      { text: \u0027Uma extensão de contexto global de estado.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Qual é a forma correta de definir um estado com useState?\u0027,\r\n    choices: [\r\n      { text: \u0027const count \u003d useState(0);\u0027, correct: false },\r\n      { text: \u0027let [count] \u003d useState(0);\u0027, correct: false },\r\n      { text: \u0027const [count, setCount] \u003d useState(0);\u0027, correct: true },\r\n      { text: \u0027useState(count \u003d 0);\u0027, correct: false },\r\n      { text: \u0027setState(count, 0);\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Para armazenar uma string com AsyncStorage, qual é a sintaxe correta?\u0027,\r\n    choices: [\r\n      { text: \u0027await AsyncStorage.save(\"key\", \"value\");\u0027, correct: false },\r\n      { text: \u0027AsyncStorage.setItem(\"key\", \"value\");\u0027, correct: true },\r\n      { text: \u0027store(\"key\", \"value\");\u0027, correct: false },\r\n      { text: \u0027AsyncStorage.write(\"key\", \"value\");\u0027, correct: false },\r\n      { text: \u0027useAsync(\"key\", \"value\");\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Como o useEffect funciona com array de dependências vazio ([])?\u0027,\r\n    choices: [\r\n      { text: \u0027Executa a função a cada renderização.\u0027, correct: false },\r\n      { text: \u0027Executa a função apenas na desmontagem do componente.\u0027, correct: false },\r\n      { text: \u0027Nunca executa a função.\u0027, correct: false },\r\n      { text: \u0027Executa a função uma vez após o primeiro render.\u0027, correct: true },\r\n      { text: \u0027Executa a função a cada clique do usuário.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Qual é a alternativa correta para navegar entre telas usando Stack Navigation?\u0027,\r\n    choices: [\r\n      { text: \u0027navigation.goBack(\"Home\");\u0027, correct: false },\r\n      { text: \u0027navigateTo(\"HomeScreen\");\u0027, correct: false },\r\n      { text: \u0027navigation.push(\"Home\");\u0027, correct: true },\r\n      { text: \u0027Router.navigate(\"Home\");\u0027, correct: false },\r\n      { text: \u0027nav.screen(\"Home\");\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Qual é o objetivo principal do useRef em animações com Animated?\u0027,\r\n    choices: [\r\n      { text: \u0027Criar referências a elementos DOM.\u0027, correct: false },\r\n      { text: \u0027Armazenar valores mutáveis que não causam re-renderizações.\u0027, correct: true },\r\n      { text: \u0027Criar estilos dinâmicos no componente.\u0027, correct: false },\r\n      { text: \u0027Substituir o useState em componentes de classe.\u0027, correct: false },\r\n      { text: \u0027Fornecer contexto global a valores animados.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Em qual situação o PanResponder seria mais adequado?\u0027,\r\n    choices: [\r\n      { text: \u0027Para responder a eventos de clique simples.\u0027, correct: false },\r\n      { text: \u0027Para capturar gestos de swipe e drag.\u0027, correct: true },\r\n      { text: \u0027Para criar navegação por abas.\u0027, correct: false },\r\n      { text: \u0027Para acessar dados persistentes.\u0027, correct: false },\r\n      { text: \u0027Para estilizar componentes dinamicamente.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O que acontece quando setState de useState é chamado?\u0027,\r\n    choices: [\r\n      { text: \u0027O componente é destruído.\u0027, correct: false },\r\n      { text: \u0027O componente ignora a atualização.\u0027, correct: false },\r\n      { text: \u0027O componente é re-renderizado com o novo valor.\u0027, correct: true },\r\n      { text: \u0027O valor anterior é descartado permanentemente.\u0027, correct: false },\r\n      { text: \u0027O componente navega automaticamente para outra tela.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Qual alternativa representa corretamente a leitura de um valor com AsyncStorage?\u0027,\r\n    choices: [\r\n      { text: \u0027const valor \u003d AsyncStorage.get(\"minhaChave\");\u0027, correct: false },\r\n      { text: \u0027const valor \u003d await AsyncStorage.getItem(\"minhaChave\");\u0027, correct: true },\r\n      { text: \u0027const valor \u003d useAsync(\"minhaChave\");\u0027, correct: false },\r\n      { text: \u0027const valor \u003d Storage.getItemSync(\"minhaChave\");\u0027, correct: false },\r\n      { text: \u0027const valor \u003d getStorageValue(\"minhaChave\");\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Qual das opções abaixo não é uma navegação fornecida por React Navigation?\u0027,\r\n    choices: [\r\n      { text: \u0027Stack\u0027, correct: false },\r\n      { text: \u0027Drawer\u0027, correct: false },\r\n      { text: \u0027Bottom Tabs\u0027, correct: false },\r\n      { text: \u0027Tabs Horizontal\u0027, correct: true },\r\n      { text: \u0027Material Top Tabs\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O que acontece se você esquecer de colocar as dependências no useEffect?\u0027,\r\n    choices: [\r\n      { text: \u0027Ele nunca será executado.\u0027, correct: false },\r\n      { text: \u0027Ele será executado apenas uma vez.\u0027, correct: false },\r\n      { text: \u0027Ele será executado após eventos de toque.\u0027, correct: false },\r\n      { text: \u0027Ele será executado após toda renderização.\u0027, correct: true },\r\n      { text: \u0027Ele causará erro fatal.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Como usar TouchableOpacity corretamente?\u0027,\r\n    choices: [\r\n      { text: \u0027Envolvendo um componente visual dentro dele e adicionando a prop onPress.\u0027, correct: true },\r\n      { text: \u0027Apenas colocando style\u003d{{ opacity: 0.5 }} em uma View.\u0027, correct: false },\r\n      { text: \u0027Criando um botão com ButtonOpacity.\u0027, correct: false },\r\n      { text: \u0027Apenas com Text dentro, sem eventos.\u0027, correct: false },\r\n      { text: \u0027Com o hook useTouchable.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Qual hook seria ideal para acessar diretamente um componente, como um campo de input?\u0027,\r\n    choices: [\r\n      { text: \u0027useEffect\u0027, correct: false },\r\n      { text: \u0027useState\u0027, correct: false },\r\n      { text: \u0027useRef\u0027, correct: true },\r\n      { text: \u0027useMemo\u0027, correct: false },\r\n      { text: \u0027useContext\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O que faz o método navigation.navigate(\"ScreenName\")?\u0027,\r\n    choices: [\r\n      { text: \u0027Retorna à tela anterior.\u0027, correct: false },\r\n      { text: \u0027Reinicia a navegação.\u0027, correct: false },\r\n      { text: \u0027Vai para a tela especificada na pilha.\u0027, correct: true },\r\n      { text: \u0027Remove a tela atual.\u0027, correct: false },\r\n      { text: \u0027Abre uma drawer lateral.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Como criar uma animação com Animated.Value?\u0027,\r\n    choices: [\r\n      { text: \u0027const opacity \u003d new Animated.Value(1);\u0027, correct: true },\r\n      { text: \u0027const opacity \u003d Animated.create(1);\u0027, correct: false },\r\n      { text: \u0027const opacity \u003d useRef(1);\u0027, correct: false },\r\n      { text: \u0027const opacity \u003d AnimatedRef(1);\u0027, correct: false },\r\n      { text: \u0027const opacity \u003d useState(1);\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O que faz o Animated.timing?\u0027,\r\n    choices: [\r\n      { text: \u0027Aplica delay entre chamadas assíncronas.\u0027, correct: false },\r\n      { text: \u0027Controla animações baseado em tempo.\u0027, correct: true },\r\n      { text: \u0027Cria um timer que reinicia o componente.\u0027, correct: false },\r\n      { text: \u0027Substitui o uso do useEffect.\u0027, correct: false },\r\n      { text: \u0027Navega entre telas com tempo pré-definido.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027O que o parâmetro gestureEnabled faz em Stack.Navigator?\u0027,\r\n    choices: [\r\n      { text: \u0027Define se a tela será atualizada com Swipe.\u0027, correct: false },\r\n      { text: \u0027Permite ou não o uso de gestos de navegação.\u0027, correct: true },\r\n      { text: \u0027Impede o uso de animações.\u0027, correct: false },\r\n      { text: \u0027Ativa um listener global de toque.\u0027, correct: false },\r\n      { text: \u0027Define o tempo de transição entre telas.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Em DrawerNavigation, o menu lateral é acessado por:\u0027,\r\n    choices: [\r\n      { text: \u0027Pressionar o botão de voltar do Android.\u0027, correct: false },\r\n      { text: \u0027Realizar swipe a partir da lateral da tela.\u0027, correct: true },\r\n      { text: \u0027Clicar em um botão flutuante.\u0027, correct: false },\r\n      { text: \u0027Usar o hook useDrawer().\u0027, correct: false },\r\n      { text: \u0027Utilizar TouchableMenu.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Por que useEffect(() \u003d\u003e {}, []) é semelhante a componentDidMount()?\u0027,\r\n    choices: [\r\n      { text: \u0027Porque executa a cada re-render.\u0027, correct: false },\r\n      { text: \u0027Porque roda antes do render inicial.\u0027, correct: false },\r\n      { text: \u0027Porque executa apenas uma vez após a montagem do componente.\u0027, correct: true },\r\n      { text: \u0027Porque ignora atualizações de estado.\u0027, correct: false },\r\n      { text: \u0027Porque é chamado no unmount do componente.\u0027, correct: false }\r\n    ]\r\n  },\r\n  {\r\n    title: \u0027Qual alternativa é correta sobre useRef com TextInput?\u0027,\r\n    choices: [\r\n      { text: \u0027Permite capturar valor digitado automaticamente.\u0027, correct: false },\r\n      { text: \u0027Permite foco programático com ref.current.focus().\u0027, correct: true },\r\n      { text: \u0027Evita que o campo aceite texto.\u0027, correct: false },\r\n      { text: \u0027Serve como listener de eventos de teclado.\u0027, correct: false },\r\n      { text: \u0027Bloqueia o re-render do componente.\u0027, correct: false }\r\n    ]\r\n  }\r\n];\r\n\r\n\r\n\r\n\r\n\r\n    // Adiciona as perguntas ao formulário\r\n    questions.forEach(function(q) {\r\n        var item \u003d copiedForm.addMultipleChoiceItem();\r\n        item.setTitle(q.title);\r\n        var choices \u003d q.choices.map(function(choice) {\r\n            return item.createChoice(choice.text, choice.correct);\r\n        });\r\n        item.setChoices(choices);\r\n        item.setPoints(1); // Define pontuação por pergunta\r\n        item.setRequired(true);\r\n    });\r\n\r\n    // Exibir o link para edição do formulário no Logger\r\n    Logger.log(\"Quiz criado: \" + copiedForm.getEditUrl());\r\n  }\r\n\r\n  // Chamar a função para criar o quiz\r\n  createQuizFromTemplate();\r\n}\r\n"}]}