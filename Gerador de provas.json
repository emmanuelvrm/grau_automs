{"files":[{"id":"9dd32614-eb63-43ac-8a6d-767f1b051b3d","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"America/Sao_Paulo\",\n  \"dependencies\": {\n  },\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\"\n}"},{"id":"c57f354e-3496-4007-ac86-1fd0c8498729","name":"Código","type":"server_js","source":" function myFunction() {\r\n\r\n  var idpasta \u003d \"1cJ1PuqazoySomjxr8zr4HzmhpRqneOdy\";\r\n  var materia \u003d \"Programação avançada - \"\r\n  \r\n  // Definir os documentos e seus títulos\r\n  var documentos \u003d [\r\n    {nome: materia+\u0027Primeira chamada\u0027, titulo: \u0027Primeira chamada\u0027, embaralhar: false},\r\n    {nome: materia+\u0027Segunda chamada\u0027, titulo: \u0027Segunda chamada\u0027, embaralhar: true},\r\n    {nome: materia+\u0027Recuperação\u0027, titulo: \u0027Recuperação\u0027, embaralhar: true}\r\n  ];\r\n\r\n  // Definição das perguntas e alternativas\r\n  var perguntas \u003d [\r\n  {\r\n    enunciado: \u0027Qual é o princípio SOLID que diz que uma classe deve ter apenas uma razão para mudar?\u0027,\r\n    alternativas: [\r\n      \u0027Single Responsibility Principle (SRP)\u0027, // A\r\n      \u0027Open-Closed Principle (OCP)\u0027,           // B\r\n      \u0027Liskov Substitution Principle (LSP)\u0027,   // C\r\n      \u0027Interface Segregation Principle (ISP)\u0027, // D\r\n      \u0027Dependency Inversion Principle (DIP)\u0027   // E\r\n    ],\r\n    resposta: \u0027A\u0027\r\n  },\r\n  {\r\n    enunciado: \u0027Qual é o padrão de design frequentemente usado para criar objetos sem especificar explicitamente suas classes, permitindo que as subclasses alterem o tipo de objetos criados?\u0027,\r\n    alternativas: [\r\n      \u0027Singleton\u0027,        // A\r\n      \u0027Factory Method\u0027,   // B\r\n      \u0027Abstract Factory\u0027, // C\r\n      \u0027Prototype\u0027,        // D\r\n      \u0027Builder\u0027           // E\r\n    ],\r\n    resposta: \u0027D\u0027\r\n  },\r\n  {\r\n    enunciado: \u0027Qual é a primeira etapa do ciclo TDD?\u0027,\r\n    alternativas: [\r\n      \u0027Implementação\u0027,        // A\r\n      \u0027Refatoração\u0027,          // B\r\n      \u0027Escrita de testes\u0027,    // C\r\n      \u0027Revisão de código\u0027,    // D\r\n      \u0027Execução de testes\u0027    // E\r\n    ],\r\n    resposta: \u0027C\u0027\r\n  },\r\n  {\r\n    enunciado: \u0027Qual é o princípio SOLID que afirma que uma classe deve estar aberta para extensão, mas fechada para modificação?\u0027,\r\n    alternativas: [\r\n      \u0027Single Responsibility Principle (SRP)\u0027, // A\r\n      \u0027Open-Closed Principle (OCP)\u0027,           // B\r\n      \u0027Liskov Substitution Principle (LSP)\u0027,   // C\r\n      \u0027Interface Segregation Principle (ISP)\u0027, // D\r\n      \u0027Dependency Inversion Principle (DIP)\u0027   // E\r\n    ],\r\n    resposta: \u0027B\u0027\r\n  },\r\n  {\r\n    enunciado: \u0027Qual é o padrão de design usado para garantir que apenas uma instância de uma classe seja criada e fornece um ponto global de acesso para essa instância?\u0027,\r\n    alternativas: [\r\n      \u0027Singleton\u0027,        // A\r\n      \u0027Factory Method\u0027,   // B\r\n      \u0027Abstract Factory\u0027, // C\r\n      \u0027Prototype\u0027,        // D\r\n      \u0027Builder\u0027           // E\r\n    ],\r\n    resposta: \u0027A\u0027\r\n  },\r\n  {\r\n    enunciado: \u0027No TDD qual é o próximo passo após escrever um teste que falha?\u0027,\r\n    alternativas: [\r\n      \u0027Implementar o código de produção\u0027, // A\r\n      \u0027Refatorar o código\u0027,               // B\r\n      \u0027Executar o teste\u0027,                 // C\r\n      \u0027Escrever outro teste\u0027,             // D\r\n      \u0027Revisar o teste escrito\u0027           // E\r\n    ],\r\n    resposta: \u0027A\u0027\r\n  },\r\n  {\r\n    enunciado: \u0027Qual é o princípio SOLID que define que objetos de uma classe derivada devem ser substituíveis por objetos de sua classe base sem quebrar a funcionalidade do programa?\u0027,\r\n    alternativas: [\r\n      \u0027Single Responsibility Principle (SRP)\u0027, // A\r\n      \u0027Open-Closed Principle (OCP)\u0027,           // B\r\n      \u0027Liskov Substitution Principle (LSP)\u0027,   // C\r\n      \u0027Interface Segregation Principle (ISP)\u0027, // D\r\n      \u0027Dependency Inversion Principle (DIP)\u0027   // E\r\n    ],\r\n    resposta: \u0027C\u0027\r\n  },\r\n  {\r\n    enunciado: \u0027Qual é o padrão de design usado para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas?\u0027,\r\n    alternativas: [\r\n      \u0027Singleton\u0027,        // A\r\n      \u0027Factory Method\u0027,   // B\r\n      \u0027Abstract Factory\u0027, // C\r\n      \u0027Prototype\u0027,        // D\r\n      \u0027Builder\u0027           // E\r\n    ],\r\n    resposta: \u0027C\u0027\r\n  },\r\n  {\r\n    enunciado: \u0027Complete corretamente as afirmativas abaixo:\\n\\n\u0027 +\r\n               \u0027I ) No TDD quado todos os testes passam devemos em seguida _____________ nosso código.\\n\u0027 +\r\n               \u0027II ) O _____________ é o padrão de design usado para construir um objeto passo a passo, onde diferentes construtores são usados para construir objetos complexos.\\n\u0027 +\r\n               \u0027III ) _____________ é o princípio SOLID que diz que módulos de alto nível não devem depender de módulos de baixo nível, mas ambos devem depender de abstrações.\u0027,\r\n    alternativas: [\r\n      \u0027Refatorar, Builder, Dependency Inversion Principle (DIP)\u0027, // A\r\n      \u0027Reconstruir, Builder, Dependency Inversion Principle (DIP)\u0027, // B\r\n      \u0027Compilar, Prototype, Liskov Substitution Principle (LSP)\u0027, // C\r\n      \u0027Compartilhar, Abstract Factory, Dependency Inversion Principle (DIP)\u0027, // D\r\n      \u0027Deletar, Factory Method, Single Responsibility Principle (SRP)\u0027 // E\r\n    ],\r\n    resposta: \u0027A\u0027\r\n  },\r\n  {\r\n    enunciado: \u0027Assinale V para as afirmativas verdadeiras e F para as falsas:\\n\u0027 +\r\n               \u0027(_____) No TDD ao iniciar a fase de refatoração o código é alterado para melhorar sua estrutura interna, sem alterar seu comportamento externo.\\n\u0027 +\r\n               \u0027(_____) O Princípio de Liskov Substitution Principle (LSP) no SOLID afirma que uma classe não deve ser forçada a implementar interfaces que ela não usa.\\n\u0027 +\r\n               \u0027(_____) Builder é o padrão de design usado para definir uma interface para criar um objeto, mas permite que as subclasses alterem o tipo de objeto que será instanciado.\\n\u0027 +\r\n               \u0027(_____) No TDD, o objetivo de escrever testes antes da implementação do código de produção é identificar falhas no código antes da implementação.\u0027,\r\n    alternativas: [\r\n      \u0027V-V-V-V\u0027, // A\r\n      \u0027V-V-V-F\u0027, // B\r\n      \u0027V-V-F-F\u0027, // C\r\n      \u0027V-F-F-V\u0027, // D\r\n      \u0027F-V-V-F\u0027  // E\r\n    ],\r\n    resposta: \u0027D\u0027\r\n  }\r\n];\r\n\r\n\r\n // Função para embaralhar as perguntas e atualizar as alternativas no gabarito\r\nfunction embaralharPerguntas(perguntas) {\r\n  for (let i \u003d perguntas.length - 1; i \u003e 0; i--) {\r\n    const j \u003d Math.floor(Math.random() * (i + 1));\r\n    [perguntas[i], perguntas[j]] \u003d [perguntas[j], perguntas[i]];\r\n  }\r\n}\r\n\r\n// Cria uma única pasta para armazenar todos os documentos\r\nvar pastaPrincipal \u003d DriveApp.getFolderById(idpasta);\r\n\r\n// Criar os documentos\r\ndocumentos.forEach(function(doc) {\r\n\r\n  // Criação do primeiro documento (Perguntas)\r\n  var perguntaDoc \u003d DocumentApp.create(doc.nome);\r\n  var perguntaBody \u003d perguntaDoc.getBody();\r\n\r\n  // Adiciona o título do documento\r\n  perguntaBody.appendParagraph(doc.titulo).setBold(true);\r\n\r\n  var urlImagem \u003d \u0027https://i.imgur.com/SPTt1aZ.png\u0027;\r\n  var imgBlob \u003d UrlFetchApp.fetch(urlImagem).getBlob();\r\n  var img \u003d perguntaBody.appendImage(imgBlob);\r\n  img.setWidth(520);\r\n  img.setHeight(180);\r\n\r\n  // Embaralha as perguntas se necessário\r\n  if (doc.embaralhar) {\r\n    embaralharPerguntas(perguntas);\r\n  }\r\n\r\n  // Adiciona as perguntas e alternativas\r\n  perguntas.forEach(function(pergunta, index) {\r\n    perguntaBody.appendParagraph((index + 1) + \" - \" + pergunta.enunciado).setBold(true);\r\n    pergunta.alternativas.forEach(function(alt, i) {\r\n      perguntaBody.appendParagraph(String.fromCharCode(97 + i) + \") \" + alt).setBold(false);\r\n    });\r\n    perguntaBody.appendParagraph(\u0027 \u0027);\r\n  });\r\n\r\n  // Geração de gabarito com base na ordem das perguntas\r\n  var gabarito \u003d [];\r\n  perguntas.forEach(function(pergunta) {\r\n    gabarito.push(pergunta.resposta);\r\n  });\r\n\r\n  // Criação do documento de Gabarito\r\n  var gabaritoDoc \u003d DocumentApp.create(\u0027Gabarito de \u0027 + doc.nome);\r\n  var gabaritoBody \u003d gabaritoDoc.getBody();\r\n\r\n  // Adiciona o título do gabarito\r\n  gabaritoBody.appendParagraph(\u0027Gabarito do \u0027 + doc.nome).setBold(true);\r\n\r\n  // Adiciona as respostas\r\n  gabarito.forEach(function(resposta, i) {\r\n    gabaritoBody.appendParagraph((i + 1) + \" – \" + resposta);\r\n  });\r\n\r\n  // Move o documento de perguntas para a pasta principal\r\n  var perguntaFile \u003d DriveApp.getFileById(perguntaDoc.getId());\r\n  pastaPrincipal.addFile(perguntaFile);\r\n  DriveApp.getRootFolder().removeFile(perguntaFile);\r\n\r\n  // Move o gabarito para a mesma pasta principal\r\n  var gabaritoFile \u003d DriveApp.getFileById(gabaritoDoc.getId());\r\n  pastaPrincipal.addFile(gabaritoFile);\r\n  DriveApp.getRootFolder().removeFile(gabaritoFile);\r\n\r\n  // Exibe o link dos documentos criados\r\n  Logger.log(\u0027Documento de perguntas criado: \u0027 + perguntaDoc.getUrl());\r\n  Logger.log(\u0027Gabarito criado: \u0027 + gabaritoDoc.getUrl());\r\n});\r\n }"}]}